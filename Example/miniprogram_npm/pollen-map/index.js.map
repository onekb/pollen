{"version":3,"sources":["index.js","utils\\utils.js","utils\\src\\GatherCircles.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["//计算坐标\r\nvar __TEMP__ = require('./utils/utils');var copyArrayObject = __TEMP__['copyArrayObject'];\r\nvar __TEMP__ = require('./utils/src/GatherCircles');var GatherCircles = __TEMP__['GatherCircles'];\r\n\r\nclass Pollen {\r\n  //初始化\r\n  constructor(point = [], config = {\r\n    mode: 'median',//median中位数 ladder阶梯\r\n    radiusMax: 1000,//圆圈最大半径\r\n    radiusMin: 100,//圆圈最小半径\r\n  }) {\r\n    if (point)\r\n      this.setPoint(point)\r\n    this._config = config\r\n  }\r\n\r\n  //设置坐标数组\r\n  setPoint(point, onlyZombie = false) {\r\n    if (!onlyZombie)\r\n      this._point = copyArrayObject(point)//原始数据\r\n    this._pointZombie = copyArrayObject(point)//用于计算 排序啥的 会更改位置 就叫它僵尸数组吧\r\n  }\r\n\r\n  //获取处理后的标记数据\r\n  getGatherCirclesArray() {\r\n    var roundList = []\r\n    var thisRound = {}\r\n    var gatherCircles = new GatherCircles(this._pointZombie, this._config)\r\n    do {\r\n      thisRound = gatherCircles[this._config.mode]()\r\n      roundList.push(thisRound)\r\n    } while (thisRound.other.length)\r\n    return roundList\r\n  }\r\n\r\n  //获取聚集圈集合友好输出 //圈    中心点\r\n  getGatherCirclesFriendly(circles_, circlesMarkers_) {\r\n    var circlesArray = []\r\n    var circlesMarkersArray = []\r\n    var gatherCirclesArray = this.getGatherCirclesArray()\r\n    gatherCirclesArray.forEach((element, i) => {\r\n      //画圆\r\n      var circles = Object.assign({}, circles_)\r\n      circles.latitude = element.data[0].latitude\r\n      circles.longitude = element.data[0].longitude\r\n      circles.radius = element.data[element.data.length - 1].m\r\n      if (circles.radius < this._config.radiusMin) circles.radius = this._config.radiusMin\r\n      circlesArray.push(Object.assign({}, circles))\r\n\r\n      //下标签\r\n      var circlesMarkers = Object.assign({}, circlesMarkers_)\r\n      circlesMarkers.callout = Object.assign({}, circlesMarkers_.callout)\r\n      circlesMarkers.id = i\r\n      circlesMarkers.latitude = element.data[0].latitude\r\n      circlesMarkers.longitude = element.data[0].longitude\r\n      circlesMarkers.callout.content = circlesMarkers.callout.content.replace(\"{num}\", element.data.length)\r\n      circlesMarkersArray.push(Object.assign({}, circlesMarkers))\r\n      delete element.other\r\n    });\r\n\r\n    return {\r\n      point: this._point,\r\n      gatherCirclesArray: gatherCirclesArray,\r\n      circles: circlesArray,\r\n      circlesMarkers: circlesMarkersArray\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  Pollen: Pollen,\r\n}","//计算坐标\r\nfunction getDisance(lat1, lng1, lat2, lng2) {\r\n  var toRad = d => {\r\n    return d * Math.PI / 180;\r\n  }\r\n  var dis = 0;\r\n  var radLat1 = toRad(lat1);\r\n  var radLat2 = toRad(lat2);\r\n  var deltaLat = radLat1 - radLat2;\r\n  var deltaLng = toRad(lng1) - toRad(lng2);\r\n  var dis = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(deltaLat / 2), 2) + Math.cos(radLat1) * Math.cos(radLat2) * Math.pow(Math.sin(deltaLng / 2), 2)));\r\n  return dis * 6378137;\r\n}\r\n\r\n//取中位数\r\nfunction getMedian(arr) {\r\n  arr = arr.sort()\r\n  return arr[Math.round(arr.length / 2) - 1]\r\n}\r\n\r\n//深拷贝数组对象\r\nfunction copyArrayObject(arrayObject) {\r\n  return arrayObject.map(element => Object.assign({}, element))\r\n}\r\n\r\n//排序数组对象\r\nfunction sortArrayObject(arr, objKey, order = 'asc') {\r\n  return arr.sort(function (a, b) {\r\n    return order == 'asc' ? a[objKey] - b[objKey] : b[objKey] - a[objKey]\r\n  })\r\n}\r\n\r\nmodule.exports = {\r\n  getDisance: getDisance,\r\n  getMedian: getMedian,\r\n  copyArrayObject: copyArrayObject,\r\n  sortArrayObject: sortArrayObject\r\n}","var __TEMP__ = require('../utils');var getMedian = __TEMP__['getMedian'];var getDisance = __TEMP__['getDisance'];var sortArrayObject = __TEMP__['sortArrayObject'];\r\n\r\nclass GatherCircles {\r\n    //初始化\r\n    constructor(_pointZombie, _config) {\r\n        this._pointZombie = _pointZombie//随时可以变化的坐标数据 我称为僵尸坐标\r\n        this._config = _config//配置\r\n    }\r\n\r\n    //中位数整合数据\r\n    median() {\r\n        //计算中位数\r\n        var latitude = []\r\n        var longitude = []\r\n        this._pointZombie.forEach(element => {\r\n            latitude.push(element.latitude)\r\n            longitude.push(element.longitude)\r\n        });\r\n        var median = [getMedian(latitude), getMedian(longitude)]\r\n\r\n        this._pointZombie.forEach(element => element.m = getDisance(median[0], median[1], element.latitude, element.longitude));\r\n        this._pointZombie = sortArrayObject(this._pointZombie, 'm')\r\n\r\n        //距离差距最小的为聚集点，重新计算每个点与聚集点的距离 然后重新排序\r\n        this._pointZombie.forEach(element => element.m = getDisance(this._pointZombie[0].latitude, this._pointZombie[0].longitude, element.latitude, element.longitude));\r\n        this._pointZombie = sortArrayObject(this._pointZombie, 'm')\r\n        var thisRound = {\r\n            data: [],\r\n            other: []\r\n        }\r\n        this._pointZombie.forEach((element, i) => {\r\n            element.m <= this._config.radiusMax ? thisRound.data.push(element) : thisRound.other.push(element)//范围内为一个group 其他未other\r\n        });\r\n        this._pointZombie = thisRound.other//将剩余的重新放入僵尸坐标\r\n        return thisRound\r\n    }\r\n\r\n    //阶梯整合数据\r\n    //每个点计算于每个点的距离 在配置最大范围内的为匹配点 匹配点数最多的作为中心\r\n    ladder() {\r\n        var thisRound = []\r\n        this._pointZombie.forEach(elementI => {\r\n            var num = 0\r\n            var thisFor = {\r\n                data: [],\r\n                other: [],\r\n                num: 0\r\n            }\r\n            this._pointZombie.forEach(elementJ => {\r\n                elementJ.m = getDisance(elementI.latitude, elementI.longitude, elementJ.latitude, elementJ.longitude)\r\n                if (elementJ.m <= this._config.radiusMax) {//判断是否为匹配点\r\n                    thisFor.data.push(Object.assign({}, elementJ))\r\n                    num++\r\n                } else {\r\n                    thisFor.other.push(Object.assign({}, elementJ))\r\n                }\r\n            })\r\n            thisFor.num = num\r\n            sortArrayObject(thisFor.data, 'm')\r\n            thisRound.push(thisFor)\r\n        })\r\n        thisRound = sortArrayObject(thisRound, 'num', 'desc')\r\n        this._pointZombie = thisRound[0].other//将剩余的重新放入僵尸坐标\r\n        return {\r\n            data: thisRound[0].data,\r\n            other: thisRound[0].other,\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    GatherCircles: GatherCircles,\r\n}"]}